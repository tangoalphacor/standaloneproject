// Verilog RAM Code Generator - Completely Free Implementation

import type { RAMConfig, VerilogCode, RAMSize } from '../types';
import { RAM_CONFIGS } from '../types';

/**
 * Generate parameterized Verilog RAM module code
 */
export function generateRAMVerilog(ramSize: RAMSize): VerilogCode {
  const config = RAM_CONFIGS[ramSize];
  
  const moduleCode = generateRAMModule(config);
  const testbenchCode = generateTestbench(config);
  
  return {
    module: moduleCode,
    testbench: testbenchCode,
  };
}

/**
 * Generate the main RAM module
 */
function generateRAMModule(config: RAMConfig): string {
  const { dataWidth, addressWidth, depth } = config;
  
  const copyrightHeader = `/*
 * ${config.size} RAM Module - Generated by Verilog RAM Generator
 * 
 * Copyright Notice:
 * This code is generated by Verilog RAM Generator created by Abhinav Kannan
 * 
 * License: FREE TO USE - No restrictions for educational or commercial use
 * - Use in any project (personal, academic, commercial)
 * - Modify and enhance as needed
 * - Distribute without limitations
 * - No attribution required (but appreciated)
 * 
 * Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}
 * Contact: abhinavkannan434@gmail.com
 * 
 * Technical Specifications:
 * - Memory Size: ${config.size}
 * - Data Width: ${dataWidth} bits
 * - Address Width: ${addressWidth} bits
 * - Memory Depth: ${depth.toLocaleString()} words
 */

`;
  
  return copyrightHeader + `// ${config.size} RAM Module Implementation
// Memory Depth: ${depth.toLocaleString()} words

module ram_${config.size.toLowerCase()} #(
    parameter DATA_WIDTH = ${dataWidth},
    parameter ADDR_WIDTH = ${addressWidth},
    parameter DEPTH = ${depth}
) (
    input  wire                    clk,
    input  wire                    rst_n,
    input  wire                    we,           // Write enable
    input  wire                    re,           // Read enable
    input  wire [ADDR_WIDTH-1:0]   addr,         // Address
    input  wire [DATA_WIDTH-1:0]   data_in,      // Data input
    output reg  [DATA_WIDTH-1:0]   data_out,     // Data output
    output reg                     ready         // Ready signal
);

    // Memory array
    reg [DATA_WIDTH-1:0] memory [0:DEPTH-1];
    
    // Internal signals
    reg [DATA_WIDTH-1:0] data_out_reg;
    reg ready_reg;
    
    // Initialize memory
    integer i;
    initial begin
        for (i = 0; i < DEPTH; i = i + 1) begin
            memory[i] = {DATA_WIDTH{1'b0}};
        end
        data_out = {DATA_WIDTH{1'b0}};
        ready = 1'b0;
    end
    
    // Main memory operations
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_out <= {DATA_WIDTH{1'b0}};
            ready <= 1'b0;
        end else begin
            ready <= 1'b0;
            
            // Write operation
            if (we && (addr < DEPTH)) begin
                memory[addr] <= data_in;
                ready <= 1'b1;
                $display("Time %0t: Write operation - Address: 0x%h, Data: 0x%h", 
                         $time, addr, data_in);
            end
            
            // Read operation
            else if (re && (addr < DEPTH)) begin
                data_out <= memory[addr];
                ready <= 1'b1;
                $display("Time %0t: Read operation - Address: 0x%h, Data: 0x%h", 
                         $time, addr, memory[addr]);
            end
            
            // Invalid address
            else if ((we || re) && (addr >= DEPTH)) begin
                ready <= 1'b0;
                $display("Time %0t: Error - Invalid address: 0x%h (max: 0x%h)", 
                         $time, addr, DEPTH-1);
            end
        end
    end
    
    // Address boundary checking
    always @(*) begin
        if (addr >= DEPTH) begin
            $warning("Address 0x%h exceeds memory depth 0x%h", addr, DEPTH);
        end
    end

endmodule`;
}

/**
 * Generate testbench for the RAM module
 */
function generateTestbench(config: RAMConfig): string {
  const { dataWidth, addressWidth } = config;
  
  const copyrightHeader = `/*
 * Testbench for ${config.size} RAM Module - Generated by Verilog RAM Generator
 * 
 * Copyright Notice:
 * This testbench is generated by Verilog RAM Generator created by Abhinav Kannan
 * 
 * License: FREE TO USE - No restrictions for educational or commercial use
 * - Use in any verification project
 * - Modify and enhance as needed
 * - Distribute without limitations
 * - No attribution required (but appreciated)
 * 
 * Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}
 * Contact: abhinavkannan434@gmail.com
 */

`;
  
  return copyrightHeader + `// Testbench Implementation for ${config.size} RAM Module

\`timescale 1ns/1ps

module ram_${config.size.toLowerCase()}_tb;

    // Parameters
    parameter DATA_WIDTH = ${dataWidth};
    parameter ADDR_WIDTH = ${addressWidth};
    parameter DEPTH = ${config.depth};
    parameter CLK_PERIOD = 10; // 100MHz clock
    
    // Testbench signals
    reg                    clk;
    reg                    rst_n;
    reg                    we;
    reg                    re;
    reg [ADDR_WIDTH-1:0]   addr;
    reg [DATA_WIDTH-1:0]   data_in;
    wire [DATA_WIDTH-1:0]  data_out;
    wire                   ready;
    
    // Test variables
    integer i;
    reg [DATA_WIDTH-1:0] expected_data;
    integer error_count = 0;
    integer test_count = 0;
    
    // Instantiate the RAM module
    ram_${config.size.toLowerCase()} #(
        .DATA_WIDTH(DATA_WIDTH),
        .ADDR_WIDTH(ADDR_WIDTH),
        .DEPTH(DEPTH)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .we(we),
        .re(re),
        .addr(addr),
        .data_in(data_in),
        .data_out(data_out),
        .ready(ready)
    );
    
    // Clock generation
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end
    
    // Test stimulus
    initial begin
        $display("Starting ${config.size} RAM Testbench");
        $display("Data Width: %d bits", DATA_WIDTH);
        $display("Address Width: %d bits", ADDR_WIDTH);
        $display("Memory Depth: %d words", DEPTH);
        $display("----------------------------------------");
        
        // Initialize signals
        rst_n = 0;
        we = 0;
        re = 0;
        addr = 0;
        data_in = 0;
        
        // Reset sequence
        #(CLK_PERIOD * 2);
        rst_n = 1;
        #(CLK_PERIOD);
        
        // Test 1: Basic write and read
        $display("Test 1: Basic Write/Read Operations");
        for (i = 0; i < 10; i = i + 1) begin
            test_write_read(i, $random);
        end
        
        // Test 2: Sequential address test
        $display("\\nTest 2: Sequential Address Test");
        for (i = 0; i < 100; i = i + 1) begin
            test_write_read(i, i * 2 + 1);
        end
        
        // Test 3: Random address test
        $display("\\nTest 3: Random Address Test");
        for (i = 0; i < 50; i = i + 1) begin
            test_write_read($random % 1000, $random);
        end
        
        // Test 4: Boundary conditions
        $display("\\nTest 4: Boundary Conditions");
        test_write_read(0, 64'hDEADBEEFCAFEBABE);
        test_write_read(DEPTH-1, 64'h123456789ABCDEF0);
        
        // Test 5: Invalid address (should fail gracefully)
        $display("\\nTest 5: Invalid Address Test");
        test_invalid_address();
        
        // Results
        $display("\\n========================================");
        $display("Test Results:");
        $display("Total Tests: %d", test_count);
        $display("Errors: %d", error_count);
        if (error_count == 0) begin
            $display("ALL TESTS PASSED! ✓");
        end else begin
            $display("SOME TESTS FAILED! ✗");
        end
        $display("========================================");
        
        #(CLK_PERIOD * 5);
        $finish;
    end
    
    // Task for write/read test
    task test_write_read;
        input [ADDR_WIDTH-1:0] test_addr;
        input [DATA_WIDTH-1:0] test_data;
        begin
            test_count = test_count + 1;
            
            // Write operation
            @(posedge clk);
            we = 1;
            re = 0;
            addr = test_addr;
            data_in = test_data;
            
            @(posedge clk);
            wait(ready);
            we = 0;
            
            // Read operation
            @(posedge clk);
            we = 0;
            re = 1;
            addr = test_addr;
            
            @(posedge clk);
            wait(ready);
            
            // Check result
            if (data_out !== test_data) begin
                $error("Address 0x%h: Expected 0x%h, Got 0x%h", 
                       test_addr, test_data, data_out);
                error_count = error_count + 1;
            end else begin
                $display("✓ Address 0x%h: Data 0x%h verified", test_addr, test_data);
            end
            
            re = 0;
            @(posedge clk);
        end
    endtask
    
    // Task for invalid address test
    task test_invalid_address;
        begin
            test_count = test_count + 1;
            
            @(posedge clk);
            we = 1;
            re = 0;
            addr = DEPTH; // Invalid address
            data_in = 64'hDEADBEEF;
            
            @(posedge clk);
            #(CLK_PERIOD * 2); // Wait a bit
            
            if (ready) begin
                $error("Invalid address should not set ready signal");
                error_count = error_count + 1;
            end else begin
                $display("✓ Invalid address correctly rejected");
            end
            
            we = 0;
            @(posedge clk);
        end
    endtask
    
    // Monitor for debugging
    initial begin
        $monitor("Time=%0t rst_n=%b we=%b re=%b addr=0x%h data_in=0x%h data_out=0x%h ready=%b", 
                 $time, rst_n, we, re, addr, data_in, data_out, ready);
    end
    
    // Waveform dump (for GTKWave)
    initial begin
        $dumpfile("ram_${config.size.toLowerCase()}_tb.vcd");
        $dumpvars(0, ram_${config.size.toLowerCase()}_tb);
    end

endmodule`;
}

/**
 * Simple in-browser Verilog simulator for basic validation
 */
export class SimpleVerilogSimulator {
  private memory: Map<number, number> = new Map();
  private logs: string[] = [];
  private config: RAMConfig;
  
  constructor(config: RAMConfig) {
    this.config = config;
    this.reset();
  }
  
  reset(): void {
    this.memory.clear();
    this.logs = [];
    this.addLog(`Simulator reset - ${this.config.size} RAM initialized`);
  }
  
  write(address: number, data: number): boolean {
    if (address >= this.config.depth) {
      this.addLog(`ERROR: Address 0x${address.toString(16)} exceeds memory depth`);
      return false;
    }
    
    this.memory.set(address, data);
    this.addLog(`WRITE: Address 0x${address.toString(16)} = 0x${data.toString(16)}`);
    return true;
  }
  
  read(address: number): number | null {
    if (address >= this.config.depth) {
      this.addLog(`ERROR: Address 0x${address.toString(16)} exceeds memory depth`);
      return null;
    }
    
    const data = this.memory.get(address) || 0;
    this.addLog(`READ: Address 0x${address.toString(16)} = 0x${data.toString(16)}`);
    return data;
  }
  
  getLogs(): string[] {
    return [...this.logs];
  }
  
  private addLog(message: string): void {
    const timestamp = new Date().toLocaleTimeString();
    this.logs.push(`[${timestamp}] ${message}`);
  }
  
  runBasicTest(): string[] {
    this.reset();
    this.addLog("Starting basic simulation test...");
    
    // Test basic write/read operations
    const testData = [
      { addr: 0x0, data: 0xDEADBEEF },
      { addr: 0x1, data: 0xCAFEBABE },
      { addr: 0x100, data: 0x12345678 },
      { addr: 0x1000, data: 0x9ABCDEF0 },
    ];
    
    let passed = 0;
    let failed = 0;
    
    for (const test of testData) {
      // Write
      if (this.write(test.addr, test.data)) {
        // Read and verify
        const readData = this.read(test.addr);
        if (readData === test.data) {
          this.addLog(`✓ Test passed for address 0x${test.addr.toString(16)}`);
          passed++;
        } else {
          this.addLog(`✗ Test failed for address 0x${test.addr.toString(16)}: expected 0x${test.data.toString(16)}, got 0x${(readData || 0).toString(16)}`);
          failed++;
        }
      } else {
        failed++;
      }
    }
    
    // Test invalid address
    this.addLog("Testing invalid address...");
    const invalidResult = this.write(this.config.depth + 1, 0x12345678);
    if (!invalidResult) {
      this.addLog("✓ Invalid address correctly rejected");
      passed++;
    } else {
      this.addLog("✗ Invalid address should have been rejected");
      failed++;
    }
    
    this.addLog(`Simulation complete: ${passed} passed, ${failed} failed`);
    return this.getLogs();
  }
}
